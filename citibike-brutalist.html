<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Citi Bike — Brutalist Flow</title>
<meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Leaflet -->
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css">
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

<style>
  /* Page + map */
  html,body{height:100%;margin:0;font-family:ui-monospace,Menlo,Consolas,monospace}
  #map{height:100vh}

  /* Controls: bottom-docked brutalist bar */
  .controls{
    position:fixed;bottom:0;left:0;right:0;z-index:1000;
    background:#fff;border-top:2px solid #000;
    padding:8px 12px;display:flex;gap:12px;align-items:center;
    font-size:12px;text-transform:uppercase;letter-spacing:.02em;
  }
  .controls label{display:flex;gap:8px;align-items:center}
  .controls .spacer{flex:1}
  .controls .chip{border:2px solid #000;background:#fff;color:#000;padding:3px 6px}

  /* Flat dropdown — rectangular, same white background */
  .controls select{
    border:2px solid #000;
    background:#fff;
    color:#000;
    padding:4px 6px;
    font:inherit;
    cursor:pointer;
    appearance:none;
    -webkit-appearance:none;
    -moz-appearance:none;
    border-radius:0;
  }
  .controls select:focus{outline:none;background:#eee}

  /* Slider – stark track + rectangular thumb */
  .controls input[type=range]{
    border:none;background:transparent;font:inherit;cursor:pointer;
    appearance:none;border-radius:0;
    height:20px;
  }
  /* WebKit */
  .controls input[type=range]::-webkit-slider-runnable-track{height:4px;background:#000;border:none}
  .controls input[type=range]::-webkit-slider-thumb{
    -webkit-appearance:none;height:16px;width:8px;background:#fff;border:2px solid #000;margin-top:-6px;cursor:pointer
  }
  /* Firefox */
  .controls input[type=range]::-moz-range-track{height:4px;background:#000;border:none}
  .controls input[type=range]::-moz-range-thumb{
    height:16px;width:8px;background:#fff;border:2px solid #000;cursor:pointer
  }

  /* Leaflet popup frame to match style */
  .leaflet-popup-content-wrapper,.leaflet-popup-tip{
    border:2px solid #000;box-shadow:none;border-radius:0;background:#fff
  }
  .leaflet-popup-content{margin:10px 12px;font-size:12px;line-height:1.3}
</style>
</head>
<body>
<div id="map" role="region" aria-label="Citi Bike flow map"></div>

<!-- Bottom controls -->
<div class="controls" role="group">
  <label>
    <span>Window</span>
    <select id="windowSelect" aria-label="Aggregation window">
      <option value="now">Last 15 min</option>
      <option value="hour">Current hour</option>
      <option value="day" selected>Today so far</option>
    </select>
  </label>

  <label>
    <span>Min |net|</span>
    <input id="thresh" type="range" min="0" max="20" step="1" value="3" aria-label="Visibility threshold">
    <span id="threshVal" class="chip">3</span>
  </label>

  <span class="spacer"></span>
  <span id="lastUpdate" class="chip">…</span>
</div>

<script>
/* Config */
const INFO_URL="https://gbfs.citibikenyc.com/gbfs/en/station_information.json";
const STATUS_URL="https://gbfs.citibikenyc.com/gbfs/en/station_status.json";
const POLL_MS=60000, SHORT_WIN=15*60*1000;
const BLUE="#2980b9", ORANGE="#f39c12";
const SNAPSHOT_URL="https://vertefeuilles.github.io/bike-tracker/snapshot.json";

/* State */
const infoById={}, lastSeen={}, deltas={}, markers={};
let windowMode="day", threshold=3;
let hasSnapshotPaint = false; // ← keep snapshot dots until real deltas arrive

/* Map */
const map=L.map("map").setView([40.73,-73.99],13);
L.tileLayer("https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png",
  {attribution:"© OpenStreetMap & CARTO", maxZoom:19}).addTo(map);

// Labels overlay (names only)
map.createPane('labels');
map.getPane('labels').style.zIndex = 650;
map.getPane('labels').style.pointerEvents = 'none';
L.tileLayer(
  'https://{s}.basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}{r}.png',
  { pane: 'labels', attribution: '© OSM & CARTO', opacity: 0.9 }
).addTo(map);

/* Helpers */
function aggregate(arr,mode,endMs){
  if(!arr||!arr.length) return 0; let net=0;
  if(mode==="now"){
    const from=endMs-SHORT_WIN;
    for(let i=arr.length-1;i>=0;i--){const e=arr[i]; if(e.t<from)break; if(e.t<=endMs) net+=e.delta;}
  }else if(mode==="hour"){
    const d=new Date(endMs); d.setMinutes(0,0,0); const from=d.getTime();
    for(let i=arr.length-1;i>=0;i--){const e=arr[i]; if(e.t<from)break; if(e.t<=endMs) net+=e.delta;}
  }else{ // day
    const d=new Date(endMs); d.setHours(0,0,0,0); const from=d.getTime();
    for(let i=arr.length-1;i>=0;i--){const e=arr[i]; if(e.t<from)break; if(e.t<=endMs) net+=e.delta;}
  }
  return net;
}
function radiusFor(net){const b=Math.sqrt(Math.abs(net)); return Math.max(4, Math.min(18, b*2.2));}

/* Preload from server snapshot and seed deltas */
async function trySeedFromSnapshot(){
  try{
    const r = await fetch(SNAPSHOT_URL, { cache: "no-store" });
    if(!r.ok) return;
    const snap = await r.json();

    // Build id -> net
    const byStation = Object.create(null);
    for(const s of snap.stations) byStation[s.id] = s.net;

    // 1) Paint immediately
    for(const id in infoById){
      const net = byStation[id] || 0;
      const show = Math.abs(net) >= threshold;
      const m = markers[id]; if(!m) continue;
      if(show){
        const color  = net > 0 ? ORANGE : (net < 0 ? BLUE : "#bbb");
        const radius = radiusFor(net);
        const info   = infoById[id];
        m.setStyle({ fillColor: color, color: "#111", radius, weight: 1, fillOpacity: .9, opacity: 1 });
        m.bindPopup(`<strong>${info.name}</strong><br/>Net: <strong>${net}</strong> (${net<0?"pickups [blue]":"dropoffs [orange] or no change"})`);
      } else {
        m.setStyle({ fillOpacity:0, opacity:0, weight:0 });
      }
    }

    // 2) Seed synthetic deltas so the first live render doesn't clear them
    const t = Date.now();
    for(const id in byStation){
      const net = byStation[id];
      if(net === 0) continue;
      if(!deltas[id]) deltas[id] = [];
      deltas[id].push({ t, delta: net });
    }

    hasSnapshotPaint = true; // ← important
    document.getElementById("lastUpdate").textContent =
      "Precomputed " + new Date(snap.generated_at).toLocaleTimeString();
  }catch(_e){
    // ignore; live polling will handle it
  }
}

/* Data */
async function loadInfo(){
  const r=await fetch(INFO_URL);
  if(!r.ok) throw new Error("station_information fetch failed: "+r.status);
  const stations=(await r.json()).data.stations;
  for(const s of stations){
    infoById[s.station_id]=s; // includes capacity (if provided)
    markers[s.station_id]=L.circleMarker([s.lat,s.lon],{
      radius:4,weight:0,color:"#111",fillColor:"#bbb",fillOpacity:0,opacity:0
    }).addTo(map);
  }
}

async function pollStatus(){
  const r=await fetch(STATUS_URL);
  if(!r.ok) throw new Error("station_status fetch failed: "+r.status);
  const now=Date.now();
  const stations=(await r.json()).data.stations;

  let anyDelta=false;

  for(const s of stations){
    const id=s.station_id;
    const bikes=s.num_bikes_available;

    if(typeof bikes!=="number") continue;

    // Treat station as "operational" only if installed + renting + returning
    const installed = s.is_installed === 1 || s.is_installed === true;
    const renting   = s.is_renting   === 1 || s.is_renting   === true;
    const returning = s.is_returning === 1 || s.is_returning === true;
    const operational = installed && renting && returning;

    if(lastSeen[id]==null){
      lastSeen[id]=bikes; // seed baseline
      continue;
    }

    const prev=lastSeen[id];
    const delta=bikes-prev;

    // Update baseline regardless (prevents future spikes when a closed station reopens)
    lastSeen[id]=bikes;

    // Skip non-operational stations (maintenance/closures)
    if(!operational) continue;

    // Filter out improbable truck moves within a 60s tick (not rider flow)
    const cap = infoById[id]?.capacity;
    const bigJump = Math.abs(delta) > (cap ? Math.max(10, Math.ceil(cap*0.35)) : 15);
    if(delta!==0 && !bigJump){
      anyDelta=true;
      if(!deltas[id]) deltas[id]=[];
      deltas[id].push({t:now, delta});
      // prune history to ~36h
      const cutoff=now-36*60*60*1000;
      while(deltas[id].length && deltas[id][0].t<cutoff) deltas[id].shift();
    }
  }

  document.getElementById("lastUpdate").textContent="Updated "+new Date(now).toLocaleTimeString();

  // Only re-render when we have new rider-like deltas, or if snapshot never painted
  if(anyDelta || !hasSnapshotPaint){
    render();
  }
}

/* Render */
function render(){
  const endMs=Date.now();
  for(const id in infoById){
    const net=aggregate(deltas[id], windowMode, endMs);
    const show=Math.abs(net)>=threshold;
    const m=markers[id]; if(!m) continue;

    if(show){
      const color=net>0?ORANGE:(net<0?BLUE:"#bbb");
      const radius=radiusFor(net);
      const s=infoById[id];
      m.setStyle({fillColor:color,color:"#111",radius,weight:1,fillOpacity:.9,opacity:1});
      m.bindPopup(`<strong>${s.name}</strong><br/>Net: <strong>${net}</strong> (${net<0?"pickups [blue]":"dropoffs [orange] or no change"})`);
    }else{
      m.setStyle({fillOpacity:0,opacity:0,weight:0});
      if(m.isPopupOpen && m.isPopupOpen()) m.closePopup();
    }
  }
}

/* UI */
document.getElementById("windowSelect").addEventListener("change", e=>{
  windowMode=e.target.value; render();
});
document.getElementById("thresh").addEventListener("input", e=>{
  threshold=Number(e.target.value);
  document.getElementById("threshVal").textContent=String(threshold);
  render();
});

/* Init */
(async function init(){
  try{
    await loadInfo();
    await trySeedFromSnapshot();   // instant paint + seed
    await pollStatus();            // live data begins
    setInterval(pollStatus, POLL_MS);
  }catch(err){
    console.error(err);
    document.getElementById("lastUpdate").textContent =
      "Error: " + (err?.message || err);
  }
})();
</script>
</body>
</html>
